\subsection{Miscellaneous}

\begin{lstlisting}[style=CStyle]
qTime_t qClock_Convert2Time( const qClock_t t )
\end{lstlisting}

Convert the specified input time(epochs) to time(seconds). \index{\lstinline{qClock_Convert2Time}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{t} : The time in epochs
\end{itemize}

\subsubsection*{Return value:}
Time \lstinline{t} in seconds.
 
\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qClock_t qClock_Convert2Clock( const qTime_t t )
\end{lstlisting}

Convert the specified input time(seconds) to time(epochs). \index{\lstinline{qClock_Convert2Clock}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{t} : The time in seconds
\end{itemize}

\subsubsection*{Return value:}
 Time \lstinline{t} in epochs.

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qBool_t qIOUtil_SwapBytes( void *data, size_t n )
\end{lstlisting}

Invert the endianess for \lstinline{n} bytes of the specified memory location. \index{\lstinline{qIOUtil_SwapBytes}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{data} : A pointer to block of data.
    \item \lstinline{n} : Number of bytes to swap.
\end{itemize}

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qBool_t qIOUtil_CheckEndianness( void )
\end{lstlisting}

Check the system endianess. \index{\lstinline{qIOUtil_CheckEndianness}}

\subsubsection*{Return value:}
\lstinline{qTrue} if little-endian, otherwise returns \lstinline{qFalse}.

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qBool_t qIOUtil_OutputRaw( qPutChar_t fcn, void* storagep, void *data, 
                        size_t n, qBool_t AIP )
qBool_t qIOUtil_InputRaw( qGetChar_t fcn, void* storagep, void *data, 
                       size_t n, qBool_t AIP )
\end{lstlisting}

Wrapper methods to write(\lstinline{qIOUtil_OutputRaw}) \index{\lstinline{qIOUtil_OutputRaw}} or read(\lstinline{qIOUtil_InputRaw}) \index{\lstinline{qIOUtil_InputRaw}} \lstinline{n} RAW data through \lstinline{fcn}.

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{fcn} : The basic output or input byte function.
    \item \lstinline{storagep} : The storage pointer passed to \lstinline{fcn}.
    \item \lstinline{data}: The data to be written or readed.
    \item \lstinline{n} : Number of bytes to be writte or readed.
    \item \lstinline{AIP} : Pass \lstinline{qTrue} to auto-increment the storage-pointer.
\end{itemize}

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qBool_t qIOUtil_OutputString( qPutChar_t fcn, void* storagep, const char *s, 
                           qBool_t AIP )
\end{lstlisting}

Wrapper method to write a string through \lstinline{fcn}. \index{\lstinline{qIOUtil_OutputString}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{fcn} : The basic output byte function.
    \item \lstinline{storagep} : The storage pointer passed to \lstinline{fcn}.
    \item \lstinline{s} : The string to be written.
    \item \lstinline{AIP} : Pass \lstinline{qTrue} to auto-increment the storage-pointer.
\end{itemize}

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
char* qIOUtil_U32toX( qUINT32_t value, char *str, int8_t n )
\end{lstlisting}

Converts an unsigned integer value to a null-terminated string using the 16 base and stores the result in the array given by \lstinline{str} parameter. \lstinline{str} should be an array long enough to contain any possible value. \index{\lstinline{qIOUtil_U32toX}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{value} : Value to be converted to string.
    \item \lstinline{str} : Array in memory where to store the resulting null-terminated string.
    \item \lstinline{n} : The number of chars used to represent the value in \lstinline{str}. 
\end{itemize}

\subsubsection*{Return value:}
A pointer to the resulting null-terminated string, same as parameter \lstinline{str}.

\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qUINT32_t qIOUtil_XtoU32( const char *s )
\end{lstlisting}

Converts the input string \lstinline{s} consisting of hexadecimal digits into an unsigned 
integer value. The input parameter \lstinline{s} should consist exclusively of hexadecimal 
digits, with optional whitespaces. The string will be processed one character at
a time, until the function reaches a character which it doesn't recognize
(including a null character). \index{\lstinline{qIOUtil_XtoU32}}
 
\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{s} : The hex string to be converted.
\end{itemize}

\subsubsection*{Return value:}
The numeric value in \lstinline{qUINT32_t}.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
qFloat64_t qIOUtil_AtoF( const char *s )
\end{lstlisting}

Parses the C string \lstinline{s}, interpreting its content as a floating point number and 
returns its value as a double. The function first discards as many whitespace 
characters (as in \lstinline{isspace}) as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax resembling that of floating point literals, and 
interprets them as a numerical value. The rest of the string after the last valid 
character is ignored and has no effect on the behavior of this function. \index{\lstinline{qIOUtil_AtoF}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{s} : The string beginning with the representation of a floating-point number.
\end{itemize}

\subsubsection*{Return value:}
On success, the function returns the converted floating point number as  a double value. \\
If no valid conversion could be performed, the function returns zero (0.0). \\
If the converted value would be out of the range of representable values by a \lstinline{double}, it causes undefined behavior.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
int qIOUtil_AtoI( const char *s )
\end{lstlisting}

Parses the C-string \lstinline{s} interpreting its content as an integral number, which is returned as a value of type \lstinline{int}. The function first discards as many whitespace characters (as in \lstinline{isspace}) as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value. \index{\lstinline{qIOUtil_AtoI}}
The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in \lstinline{s} is not a valid integral number, or if no such sequence exists because either \lstinline{s} is empty or it contains only whitespace characters, no conversion is performed and zero is returned.

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{s} : The string beginning with the representation of a integer number.

\end{itemize}

\subsubsection*{Return value:}
On success, the function returns the converted integral number as an int value. \\
If the converted value would be out of the range of representable values by an \lstinline{int}, it causes undefined behavior.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
char* qIOUtil_UtoA( qUINT32_t num, char* str, qUINT8_t base )
\end{lstlisting}

Converts an unsigned value to a null-terminated string using the specified base and stores the result in the array given by \lstinline{str} parameter. \lstinline{str} should be an array long enough to contain any possible value: \lstinline{(sizeof(int)*8+1)} for radix=2, i.e. 17 bytes in 16-bits platforms and 33 in 32-bits platforms. \index{\lstinline{qIOUtil_UtoA}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{num} : Value to be converted to a string.
    \item \lstinline{str} : Array in memory where to store the resulting null-terminated string.
    \item \lstinline{base} : Numerical base used to represent the value as a string, between 2 and 36, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.
\end{itemize}

\subsubsection*{Return value:}
A pointer to the resulting null-terminated string, same as parameter \lstinline{str}.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
char* qIOUtil_ItoA( qINT32_t  num, char* str, qUINT8_t base )
\end{lstlisting}

Converts an integer value to a null-terminated string using the specified \lstinline{base} and stores the result in the array given by \lstinline{str} parameter. If \lstinline{base} is 10 and value is negative, the resulting string is preceded with a minus sign (-). With any other base, value is always considered unsigned. \index{\lstinline{qIOUtil_ItoA}}

\lstinline{str} should be an array long enough to contain any possible value: \lstinline{(sizeof(int)*8+1)} for radix=2, i.e. 17 bytes in 16-bits platforms and 33 in 32-bits platforms.

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{num} : Value to be converted to a string.
    \item \lstinline{str} : Array in memory where to store the resulting null-terminated string.
    \item \lstinline{base} : Numerical base used to represent the value as a string, between 2 and 36, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.
\end{itemize}

\subsubsection*{Return value:}
A pointer to the resulting null-terminated string, same as parameter \lstinline{str}.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
char* qIOUtil_FtoA( qFloat32_t f, char *str, qUINT8_t precision )
\end{lstlisting}

Converts a float value to a formatted string. \index{\lstinline{qIOUtil_FtoA}}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{f} : Value to be converted to a string.
    \item \lstinline{str} : Array in memory where to store the resulting null-terminated string.
    \item \lstinline{precision} : Desired number of significant fractional digits in the string. (The max allowed precision is \lstinline{MAX_FTOA_PRECISION=10})
\end{itemize}

\subsubsection*{Return value:}
A pointer to the resulting null-terminated string, same as parameter \lstinline{str}.


\noindent\hrulefill

\begin{lstlisting}[style=CStyle]
char* qIOUtil_BtoA( qBool_t num, char *str )
\end{lstlisting}

Converts a boolean value to a null-terminated string. Input is considered true
with any value different to zero (0). \index{\lstinline{qIOUtil_BtoA}}
\lstinline{str} should be an array long enough to contain the output

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{num} : Value to be converted to a string.
    \item \lstinline{str} : Array in memory where to store the resulting null-terminated string.
\end{itemize}

\subsubsection*{Return value:}
A pointer to the resulting null-terminated string, same as parameter \lstinline{str}.

